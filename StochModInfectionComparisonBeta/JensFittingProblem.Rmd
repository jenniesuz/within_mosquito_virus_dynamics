---
title: "JensFittingProblem"
output: html_document
date: "2023-04-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(binom)
library(emdbook)
library(EnvStats)
library(parallel)
library(adaptivetau)
```

## Test code for beta-binomial

Data to fit to

```{r}
competenceDat <- read.csv("datCiotaOnyango.csv")
competenceDat <- competenceDat[competenceDat$Ref %in% "Ciota 2017",]
bin <- binom.confint(x=competenceDat$NumInf,n=competenceDat$ITotal,method="exact")
competenceDat$meanInf <- bin$mean
competenceDat$lowerInf <- bin$lower
competenceDat$upperInf <- bin$upper
```


Model parameters
```{r }
virus_params <- function(   muV = 0.1
                            ,infRate = 10^-7.5
                            ,prodRate = 1             
                            ,cellSpread = 10^-4        
                            ,escapeRate = 0.05     
                            ,cMax = 400                 
)
  return(as.list(environment()))

```


Model function

```{r}
infectionModel <- function(startingVirus
                           ,muV = 0.1
                           ,infRate = 10^-7.5
                           ,prodRate =   1    
                           ,cellSpread = 10^-4  
                           ,escapeRate = 0.05
                           ,cMax = 400 
){
  
  
  params <- list(muV = muV
                 ,probInf = infRate
                 ,prodRate =   prodRate 
                 ,cellSpread = cellSpread
                 ,escapeRate = escapeRate    
                 ,cMax = cMax            
  )
  
  transitions <- list(c(Gv = -1,Mc = +1)
                      ,c(Gv = -1)
                      ,c(Mc = +1)
                      ,c(Mv = +1)
                      ,c(Mv = -1)
                      ,c(Mv = -1)
  )
  
  
  lvrates <- function(y,params,t){
    return( c(y["Gv"]*params$probInf*(params$cMax-y["Mc"])
              ,params$muV*y["Gv"]
              ,params$cellSpread*y["Mc"]*(params$cMax-y["Mc"])
              ,params$prodRate*y["Mc"]
              ,params$muV*y["Mv"]
              ,params$escapeRate*y["Mv"]
    )
    
    )
  }
  
  out<-ssa.adaptivetau(c(Gv = round(startingVirus*0.003,0), Mc = 0, Mv = 0),
                       transitions, lvrates, params, tf=120
                       , tl.params=list(epsilon=0.005)) 
  return(data.frame(out))
}

```


Function to repeat above model - runs model across different input virus concentrations (startingVirus) 30 times for each input to simulate a single experiment, summarises to the number of simulations that resulted in infection

```{r}

repeatInfModel <- function(x=virus_params()
    ,startingVirus=10^competenceDat$ConcMax[competenceDat$Moz %in% "Ae. aegypti"]
){

  simEachConc <- tryCatch ({ 
    lapply(startingVirus,function(conc){
      repSim <- lapply(1:30,function(y){
        out <- infectionModel(startingVirus=conc
                              ,muV = as.numeric(x[1])
                              ,infRate = as.numeric(x[2])
                              ,prodRate = as.numeric(x[3])    
                              ,cellSpread = as.numeric(x[4])  
                              ,escapeRate = as.numeric(x[5])
                              ,cMax = as.numeric(x[6]) )
        dat <- data.frame(out)
        dat$run <- y
        dat$inf <- 0
        if(dat$Mv[length(dat$Mv)]>0){dat$inf<-1}
        return(dat[1,c("run","inf")])  # just return the run, and whether infection was established
      })
      
      
      repSims <- do.call(rbind.data.frame,repSim)
      return(data.frame("num"=sum(repSims$inf)
               ,"denom"=length(repSims$inf)
               ,"conc"=log10(conc)))
      
    }) 
    
  } , error = function(e) {
    print(e)
    return(c(NA,NA,NA))
  }
  )
  
  if(is.na(simEachConc[[1]][1])==F){  
    simDat <- do.call(rbind.data.frame,simEachConc)
    names(simDat) <- c("num","denom","conc")
    return(simDat)
  }else{
    return(c(NA,NA,NA))
  }
}
```



Replicate experiments in parallel 100 times, for now just using a range of potential virus concentrations to explore results of stochastic simulation and work through how to use these outputs in the likelihood function


```{r, echo=F, results='hide'}

params <- virus_params()
# replicate experiments across virus concentrations 
cl <- makeCluster(detectCores()-1)
clusterEvalQ(cl, {library(adaptivetau)})
environment(repeatInfModel) <- .GlobalEnv
clusterExport(cl, varlist=c("infectionModel","repeatInfModel","params"),
              envir=environment())

test <- parLapply(cl,1:100,function(y){
  #set.seed(y)
  s <- repeatInfModel(x=params
                      ,startingVirus=c(10^2,10^3,10^4,10^5,10^6,10^6.5,10^7,10^8))
  return(s)
})
stopCluster(cl)

test <- do.call(rbind,test) 

```

So now we can summarise the experiments at each virus dose into proportions and estimate the shape parameters of the beta distribution for each virus dose. Here I plot all the simulations so it can be seen that (of course) the variation in the probabilities obtained when the mean probability is c. 0.5 is greater than when its nearer 0 or 1...and there are model scenarions where there is no variation between experiments if either the input virus concentration is low enough that no infections occur or high enough that infections are established across all 30 'mosquitoes'.
 
```{r}
stats <- lapply(unique(test$conc),function(z){
  temp <- test[test$conc %in% z,]
  indPs <- temp$num/temp$denom
  meanP <- sum(temp$num)/sum(temp$denom)
  plot(1:length(temp$conc),indPs,ylim=c(0,1))
  betaEst <- tryCatch( { ebeta(indPs)$parameters 
                         
                         }
                       ,
                       error=function(cond) {
                         message(cond)
                        return(c(NA,NA))
                       }
  )
  if(is.na(betaEst[1])==F){
    betaEst <- as.numeric(betaEst)
  }    
    return(c(temp$conc[1],betaEst,meanP))
})

stats <- do.call(rbind.data.frame,stats)
names(stats) <- c("conc","shape1","shape2","mean")
```

The problem I am having is what to do when either the model mean is 0 or 1 and there is no variance in simulation probabilities - resulting in, for that virus dose, the binomial probability p not being beta distributed (right?) OR when we have data where all mosquitoes are infected so that the binomial log likelihood is infinite....

At first I thought that I could just do an if, else for the beta-binomial such that IF there are NAs (so that for some virus concentrations we haven't been able to assign shape parameters due to lack of variance in the simulations) then to return a very negative likelihood otherwise I do something like this (fitting to proportion of uninfected):

```{r}
  #  dBetaBinoms <- dbetabinom(samples$Denom-samples$NumInf     # data on number uninfected
  #                            ,shape1=samples$shape1           # estimated from simulations
  #                            ,shape2=samples$shape2
  #                            ,size=100 
  #                            ,log=T)
```

This would seem fine to me BUT I can't find good starting parameters - there are lots of combinations of parameter values that give a value of 0 or 1 for all simulations thus can't estimate shape parameters - therefore the likelihood optimisation gets stuck.

Also there is data where all mosquitoes were infected - this is also likely to be when the model also has no variance around the mean probability, so even if then I used just a binomial for that of course it doesn't make sense....

```{r}
dbinom(30,30,prob=0,log=T)
```



